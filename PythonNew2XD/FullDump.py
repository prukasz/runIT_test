"""
FullDump.py - Generates complete emulator dump for new API (PythonNew2XD)

Outputs hex packets in correct order for C parser:
1. Context configurations
2. Variable instances 
3. Variable data (scalars and arrays)
4. Code configuration
5. Block headers
6. Block inputs
7. Block outputs  
8. Block data
9. Loop control orders
"""

import struct
from typing import TextIO, List, Optional

from Enums import emu_order_t, packet_header_t
from Mem import mem_context_t
from Code import Code

# =============================================================================
# FULL DUMP CLASS
# =============================================================================
class FullDump:
    """
    Generates a complete hex dump of Code (blocks + variables) for transmission
    to ESP32 emulator.
    
    Usage:
        code = Code()
        code.add_variable(...)
        code.add_math(...)
        
        dump = FullDump(code)
        with open("output.txt", "w") as f:
            dump.write(f)
    """
    
    def __init__(self, code: Code):
        self.code = code
    
    def _write_line(self, writer: TextIO, content: str):
        """Write a line with newline."""
        writer.write(content + "\n")
    
    def _write_order(self, writer: TextIO, order: emu_order_t, comment: str = ""):
        """Write an order as hex with optional comment."""
        ord_bytes = struct.pack("<H", order.value)
        hex_str = ord_bytes.hex().upper()
        if comment:
            self._write_line(writer, f"#{comment}# {hex_str}")
        else:
            self._write_line(writer, f"#ORDER {order.name}# {hex_str}")
    
    def _write_packet(self, writer: TextIO, packet: bytes, comment: str = ""):
        """Write a single packet as hex with optional comment."""
        hex_str = packet.hex().upper()
        if comment:
            self._write_line(writer, f"#{comment}# {hex_str}")
        else:
            self._write_line(writer, hex_str)
    
    def _write_packets(self, writer: TextIO, packets: List[bytes], context_name: str):
        """Write a list of packets with context label."""
        for i, pkt in enumerate(packets):
            hex_str = pkt.hex().upper()
            self._write_line(writer, f"#{context_name} [{i}]# {hex_str}")
    
    def _write_context(self, writer: TextIO, ctx: mem_context_t, ctx_name: str):
        """
        Write complete context data:
        1. Context config packet
        2. Instance definition packets  
        3. Scalar data packets
        4. Array data packets
        """
        # 1. Context Configuration
        cfg_pkt = ctx.packet_generate_cfg()
        self._write_packet(writer, 
                          struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + cfg_pkt,
                          f"{ctx_name} CFG")
        self._write_order(writer, emu_order_t.ORD_PARSE_CONTEXT_CFG)
        
        # 2. Instance Definitions (headers + dims)
        instance_pkts = ctx.generate_packets_instances()
        if instance_pkts:
            for i, pkt in enumerate(instance_pkts):
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt,
                                  f"{ctx_name} INST [{i}]")
            self._write_order(writer, emu_order_t.ORD_PARSE_VARIABLES)
        
        # 3. Data Packets (scalars and arrays combined in generate_packets_data)
        data_pkts = ctx.generate_packets_data()
        if data_pkts:
            for i, pkt in enumerate(data_pkts):
                # Determine if scalar or array from dims_cnt in packet
                # Format: [ctx:u8][type:u8][count:u8][entries...]
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt,
                                  f"{ctx_name} DATA [{i}]")
            self._write_order(writer, emu_order_t.ORD_PARSE_VARIABLES_S_DATA)
    
    def write(self, writer: TextIO, 
              include_loop_init: bool = True,
              include_loop_start: bool = True):
        """
        Generate complete dump in correct order for C parser.
        
        :param writer: File-like object to write to
        :param include_loop_init: Include loop init order at end
        :param include_loop_start: Include loop start order at end
        """
        
        self._write_line(writer, "#" + "="*58 + "#")
        self._write_line(writer, "# FULL EMULATOR DUMP - Generated by PythonNew2XD #")
        self._write_line(writer, "#" + "="*58 + "#")
        self._write_line(writer, "")
        
        # ==========================================
        # 1. CONTEXT CONFIGURATIONS
        # ==========================================
        self._write_line(writer, "#" + "-"*32 + "#")
        self._write_line(writer, "# SECTION 1: Context Configs #")
        self._write_line(writer, "#" + "-"*32 + "#")
        
        # Context 0 config
        cfg_pkt = self.code.user_ctx.packet_generate_cfg()
        self._write_packet(writer, 
                          struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + cfg_pkt,
                          "CTX0 CFG")
        
        # Context 1 config
        cfg_pkt = self.code.blocks_ctx.packet_generate_cfg()
        self._write_packet(writer,
                          struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + cfg_pkt,
                          "CTX1 CFG")
        
        self._write_order(writer, emu_order_t.ORD_PARSE_CONTEXT_CFG)
        self._write_line(writer, "")
        
        # ==========================================
        # 2. INSTANCE DEFINITIONS
        # ==========================================
        self._write_line(writer, "#" + "-"*32 + "#")
        self._write_line(writer, "# SECTION 2: Instance Defs   #")
        self._write_line(writer, "#" + "-"*32 + "#")
        
        # Context 0 instances
        instance_pkts = self.code.user_ctx.generate_packets_instances()
        if instance_pkts:
            for i, pkt in enumerate(instance_pkts):
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt,
                                  f"CTX0 INST [{i}]")
        
        # Context 1 instances
        instance_pkts = self.code.blocks_ctx.generate_packets_instances()
        if instance_pkts:
            for i, pkt in enumerate(instance_pkts):
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt,
                                  f"CTX1 INST [{i}]")
        
        self._write_order(writer, emu_order_t.ORD_PARSE_VARIABLES)
        self._write_line(writer, "")
        
        # ==========================================
        # 3. INSTANCE DATA
        # ==========================================
        self._write_line(writer, "#" + "-"*32 + "#")
        self._write_line(writer, "# SECTION 3: Instance Data   #")
        self._write_line(writer, "#" + "-"*32 + "#")
        
        # Context 0 data
        data_pkts = self.code.user_ctx.generate_packets_data()
        if data_pkts:
            for i, pkt in enumerate(data_pkts):
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt,
                                  f"CTX0 DATA [{i}]")
        
        # Context 1 data
        data_pkts = self.code.blocks_ctx.generate_packets_data()
        if data_pkts:
            for i, pkt in enumerate(data_pkts):
                self._write_packet(writer,
                                  struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt,
                                  f"CTX1 DATA [{i}]")
        
        self._write_order(writer, emu_order_t.ORD_PARSE_VARIABLES_S_DATA)
        self._write_line(writer, "")
        
        # ==========================================
        # 4. CODE CONFIGURATION
        # ==========================================
        self._write_line(writer, "#" + "-"*26 + "#")
        self._write_line(writer, "# SECTION 4: Code Config #")
        self._write_line(writer, "#" + "-"*26 + "#")
        
        code_cfg_pkt = self.code.generate_code_cfg_packet()
        self._write_packet(writer, code_cfg_pkt, "CODE_CFG")
        self._write_order(writer, emu_order_t.ORD_PARSE_CODE_CFG)
        self._write_line(writer, "")
        
        # ==========================================
        # 5. BLOCK HEADERS
        # ==========================================
        self._write_line(writer, "#" + "-"*26 + "#")
        self._write_line(writer, "# SECTION 5: Block Hdrs  #")
        self._write_line(writer, "#" + "-"*26 + "#")
        
        blocks_sorted = self.code.get_blocks_sorted()
        for block in blocks_sorted:
            header = struct.pack('<B', packet_header_t.PACKET_H_BLOCK_HEADER)
            pkt = header + block.pack_cfg()
            self._write_packet(writer, pkt, f"BLK[{block.idx}] {block.block_type.name} HDR")
        self._write_order(writer, emu_order_t.ORD_PARSE_BLOCK_HEADER)
        self._write_line(writer, "")
        
        # ==========================================
        # 6. BLOCK INPUTS
        # ==========================================
        self._write_line(writer, "#" + "-"*26 + "#")
        self._write_line(writer, "# SECTION 6: Block Input #")
        self._write_line(writer, "#" + "-"*26 + "#")
        
        manager = self.code._manager
        for block in blocks_sorted:
            in_pkts = block.pack_inputs(manager)
            if in_pkts:
                for i, pkt in enumerate(in_pkts):
                    self._write_packet(writer, pkt, f"BLK[{block.idx}] INPUT[{i}]")
        self._write_order(writer, emu_order_t.ORD_PARSE_BLOCK_INPUTS)
        self._write_line(writer, "")
        
        # ==========================================
        # 7. BLOCK OUTPUTS
        # ==========================================
        self._write_line(writer, "#" + "-"*27 + "#")
        self._write_line(writer, "# SECTION 7: Block Output #")
        self._write_line(writer, "#" + "-"*27 + "#")
        
        for block in blocks_sorted:
            out_pkts = block.pack_outputs(manager)
            if out_pkts:
                for i, pkt in enumerate(out_pkts):
                    self._write_packet(writer, pkt, f"BLK[{block.idx}] OUTPUT[{i}]")
        self._write_order(writer, emu_order_t.ORD_PARSE_BLOCK_OUTPUTS)
        self._write_line(writer, "")
        
        # ==========================================
        # 8. BLOCK DATA
        # ==========================================
        self._write_line(writer, "#" + "-"*25 + "#")
        self._write_line(writer, "# SECTION 8: Block Data #")
        self._write_line(writer, "#" + "-"*25 + "#")
        
        has_data = False
        for block in blocks_sorted:
            if hasattr(block, 'pack_data'):
                data_pkts = block.pack_data()
                if data_pkts:
                    has_data = True
                    for pkt in data_pkts:
                        packet_id = pkt[4] if len(pkt) > 4 else 0
                        self._write_packet(writer, pkt, f"BLK[{block.idx}] DATA(0x{packet_id:02X})")
        if has_data:
            self._write_order(writer, emu_order_t.ORD_PARSE_BLOCK_DATA)
        self._write_line(writer, "")
        
        # ==========================================
        # 9. LOOP CONTROL
        # ==========================================
        self._write_line(writer, "#" + "-"*26 + "#")
        self._write_line(writer, "# SECTION 9: Loop Ctrl   #")
        self._write_line(writer, "#" + "-"*26 + "#")
        
        if include_loop_init:
            self._write_order(writer, emu_order_t.ORD_EMU_LOOP_INIT)
        if include_loop_start:
            self._write_order(writer, emu_order_t.ORD_EMU_LOOP_START)
        
        self._write_line(writer, "")
        self._write_line(writer, "#" + "="*14 + "#")
        self._write_line(writer, "# END OF DUMP #")
        self._write_line(writer, "#" + "="*14 + "#")
    
    def write_raw(self, writer: TextIO,
                  include_loop_init: bool = True,
                  include_loop_start: bool = True):
        """
        Generate minimal dump with just hex values (no comments).
        For direct transmission to device.
        """
        manager = self.code._manager
        blocks_sorted = self.code.get_blocks_sorted()
        
        # Context configs (both contexts, then order)
        cfg0 = struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + self.code.user_ctx.packet_generate_cfg()
        writer.write(cfg0.hex().upper() + "\n")
        cfg1 = struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + self.code.blocks_ctx.packet_generate_cfg()
        writer.write(cfg1.hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_CONTEXT_CFG).hex().upper() + "\n")
        
        # Instances (both contexts, then order)
        for pkt in self.code.user_ctx.generate_packets_instances():
            writer.write((struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt).hex().upper() + "\n")
        for pkt in self.code.blocks_ctx.generate_packets_instances():
            writer.write((struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt).hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_VARIABLES).hex().upper() + "\n")
        
        # Data (both contexts, then order)
        for pkt in self.code.user_ctx.generate_packets_data():
            writer.write((struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt).hex().upper() + "\n")
        for pkt in self.code.blocks_ctx.generate_packets_data():
            writer.write((struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt).hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_VARIABLES_S_DATA).hex().upper() + "\n")
        
        # Code config
        writer.write(self.code.generate_code_cfg_packet().hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_CODE_CFG).hex().upper() + "\n")
        
        # Block headers (all blocks, then order)
        for block in blocks_sorted:
            header = struct.pack('<B', packet_header_t.PACKET_H_BLOCK_HEADER)
            pkt = header + block.pack_cfg()
            writer.write(pkt.hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_BLOCK_HEADER).hex().upper() + "\n")
        
        # Block inputs (all blocks, then order)
        for block in blocks_sorted:
            for pkt in block.pack_inputs(manager):
                writer.write(pkt.hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_BLOCK_INPUTS).hex().upper() + "\n")
        
        # Block outputs (all blocks, then order)
        for block in blocks_sorted:
            for pkt in block.pack_outputs(manager):
                writer.write(pkt.hex().upper() + "\n")
        writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_BLOCK_OUTPUTS).hex().upper() + "\n")
        
        # Block data (all blocks, then order)
        has_data = False
        for block in blocks_sorted:
            if hasattr(block, 'pack_data'):
                data_pkts = block.pack_data()
                if data_pkts:
                    has_data = True
                    for pkt in data_pkts:
                        writer.write(pkt.hex().upper() + "\n")
        if has_data:
            writer.write(struct.pack("<H", emu_order_t.ORD_PARSE_BLOCK_DATA).hex().upper() + "\n")
        
        # Loop control
        if include_loop_init:
            writer.write(struct.pack("<H", emu_order_t.ORD_EMU_LOOP_INIT).hex().upper() + "\n")
        if include_loop_start:
            writer.write(struct.pack("<H", emu_order_t.ORD_EMU_LOOP_START).hex().upper() + "\n")
    
    def get_packets_list(self) -> List[bytes]:
        """
        Get all packets as a list of bytes for programmatic use.
        Returns packets in order without orders (for custom transmission).
        """
        manager = self.code._manager
        blocks_sorted = self.code.get_blocks_sorted()
        packets = []
        
        # Context configs
        packets.append(struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + 
                      self.code.user_ctx.packet_generate_cfg())
        packets.append(struct.pack('<B', packet_header_t.PACKET_H_CONTEXT_CFG) + 
                      self.code.blocks_ctx.packet_generate_cfg())
        
        # Instances
        for pkt in self.code.user_ctx.generate_packets_instances():
            packets.append(struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt)
        for pkt in self.code.blocks_ctx.generate_packets_instances():
            packets.append(struct.pack('<B', packet_header_t.PACKET_H_INSTANCE) + pkt)
        
        # Data
        for pkt in self.code.user_ctx.generate_packets_data():
            packets.append(struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt)
        for pkt in self.code.blocks_ctx.generate_packets_data():
            packets.append(struct.pack('<B', packet_header_t.PACKET_H_INSTANCE_SCALAR_DATA) + pkt)
        
        # Code config
        packets.append(self.code.generate_code_cfg_packet())
        
        # Block packets
        for block in blocks_sorted:
            header = struct.pack('<BH', packet_header_t.PACKET_H_BLOCK_HEADER, block.idx)
            packets.append(header + block.pack_cfg())
        
        for block in blocks_sorted:
            packets.extend(block.pack_inputs(manager))
        
        for block in blocks_sorted:
            packets.extend(block.pack_outputs(manager))
        
        for block in blocks_sorted:
            if hasattr(block, 'pack_data'):
                data_pkts = block.pack_data()
                if data_pkts:
                    packets.extend(data_pkts)
        
        return packets


# =============================================================================
# DEMO / TEST
# =============================================================================
if __name__ == "__main__":
    from Enums import mem_types_t
    from BlockMath import BlockMath
    from BlockTimer import TimerType
    from BlockCounter import CounterMode
    from MemAcces import Ref
    import io
    
    print("=" * 70)
    print("FullDump Test - New API")
    print("=" * 70)
    
    # Create code with some blocks
    code = Code()
    
    # Add user variables
    code.add_variable(mem_types_t.MEM_F, "input_a", data=10.0)
    code.add_variable(mem_types_t.MEM_F, "input_b", data=20.0)
    code.add_variable(mem_types_t.MEM_F, "output", data=0.0)
    code.add_variable(mem_types_t.MEM_B, "enable", data=True)
    
    # Add for loop (idx 0, 100 iterations, chain_len=2, always active)
    for_loop = code.add_for(
        idx=0,
        chain_len=2,  # Chain contains 2 blocks (math and set)
        start=0.0,
        limit=999.0,  # 100 iterations
        step=1.0,
        en=code.ref("enable")  # Always active (no EN input)
    )
    
    # Add math block (idx 1) - part of for loop chain
    math = code.add_math(
        idx=1,
        expression="in_1 + in_2",
        connections=[code.ref("input_a"), code.ref("input_b")],
        en=for_loop.out[0]  # Controlled by for loop
    )
    math2 = code.add_math(
        idx=2,
        expression="in_1 + 100",
        connections=[math.out[1]],
        en=math.out[0]  # Controlled by for loop
    )
    
    # Add set block (idx 2) - part of for loop chain
    # set_blk = code.add_set(
    #     idx=3,
    #     target=code.ref("output"),
    #     value=math2.out[1]  # RESULT
    # )
    
    print(f"\n{code}")
    print(f"Blocks: {[str(b) for b in code.get_blocks_sorted()]}")
    
    # Generate dump to string
    dump = FullDump(code)
    output = io.StringIO()
    dump.write(output)
    
    print("\n" + "=" * 70)
    print("Generated Dump (with comments):")
    print("=" * 70)
    print(output.getvalue())
    
    # Also test raw output
    print("\n" + "=" * 70)
    print("Raw Dump (for transmission):")
    print("=" * 70)
    raw_output = io.StringIO()
    dump.write_raw(raw_output)
    print(raw_output.getvalue())
    
    # Save to file
    with open("test_dump.txt", "w") as f:
        dump.write(f)
    print("\nDump saved to test_dump.txt")
